---
layout: default
title: DRV8302 ç¤ºä¾‹
parent: å®ä¾‹é¡¹ç›®
description: "Arduino Simple Field Oriented Control (FOC) library ."
nav_order: 6
permalink: /drv8302_example
grand_grand_parent: Arduino <span class="simple">Simple<span class="foc">FOC</span>library</span>
toc: true
---



# DRV8302 - DRV8302 - é«˜æ€§èƒ½BLDCé©±åŠ¨å™¨<br>ä½¿ç”¨Arduino UNO

DRV8302æ˜¯ä¸€æ¬¾é«˜æ€§èƒ½BLDCé©±åŠ¨æ¿ï¼Œèƒ½å¤ŸæŒç»­æä¾›15Aç”µæµï¼Œå³°å€¼ç”µæµå¯è¾¾27Aã€‚å®ƒå…·å¤‡æ¸©åº¦å’Œè¿‡æµä¿æŠ¤åŠŸèƒ½ï¼Œæ”¯æŒåç”µåŠ¨åŠ¿å’Œä¸‰ç›¸ç”µæµæ£€æµ‹ï¼Œæœ€é‡è¦çš„æ˜¯ï¼Œå®ƒä»…éœ€3PWMä¿¡å·å³å¯è¿è¡Œï¼Œè¿™ä½¿å…¶ä¸<span class="simple">ç®€æ˜“<span class="foc">FOC</span>åº“</span>å…¼å®¹ã€‚

<blockquote class="warning">
<p class="heading">æ³¨æ„ğŸ“¢</p>
æˆªè‡³ç›®å‰ï¼ˆ<a href="https://github.com/simplefoc/Arduino-FOC/releases">1.4.1ç‰ˆæœ¬ <i class="fa fa-tag"></i></a>ï¼‰ï¼Œè¯¥åº“å°šæœªå®ç°ç”µæµæ§åˆ¶ç¯ã€‚ç”µæœºæ‰­çŸ©ç›´æ¥é€šè¿‡ç”µå‹æ§åˆ¶ã€‚<a href="voltage_torque_control"> æ›´å¤šä¿¡æ¯ã€‚</a>
</blockquote>

ä»¥ä¸‹æ˜¯æ­¤é¡¹ç›®å¯èƒ½éœ€è¦çš„ç¡¬ä»¶ç¤ºä¾‹ï¼š

[Arduino UNO](https://store.arduino.cc/arduino-uno-rev3) | [DRV8302](https://fr.aliexpress.com/item/4000126430773.html?spm=a2g0o.productlist.0.0.702a312aXmzuUK&algo_pvid=50131a88-ac88-4755-bb71-978c07ec461e&algo_expid=50131a88-ac88-4755-bb71-978c07ec461e-5&btsid=0b0a119a15957548552557385e6f5e&ws_ab_test=searchweb0_0,searchweb201602_,searchweb201603_) | [AMT 103ç¼–ç å™¨](https://www.mouser.fr/ProductDetail/CUI-Devices/AMT103-V?qs=%2Fha2pyFaduiAsBlScvLoAWHUnKz39jAIpNPVt58AQ0PVb84dpbt53g%3D%3D) | [GBM5108-120T](https://www.onedrone.com/store/ipower-gbm5108-120t-gimbal-motor.html)
--- | --- | --- | --- 
<img src="extras/Images/arduino_uno.jpg" class="imgtable150"> |  <img src="extras/Images/drv8302.png" class="imgtable150">  | <img src="extras/Images/enc1.png" class="imgtable150">  |  <img src="extras/Images/bigger.jpg" class="imgtable150">

ä»¥ä¸‹æ˜¯ä½¿ç”¨Arduino UNOçš„è¿æ¥æ–¹æ¡ˆç¤ºä¾‹ï¼š

<p><img src="extras/Images/drv8302_arduino_connection.jpg" class="img400"></p>

## DRV8302
- ä¸æœ¬åº“æ”¯æŒçš„å…¶ä»–BLDCé©±åŠ¨å™¨ä¸€æ ·ï¼Œè¯¥æ¿æ¥æ”¶3PWMä¿¡å·ï¼špwm `a`ã€`b`å’Œ`c`ã€‚å°†å®ƒä»¬è¿æ¥åˆ°`INHA`ã€`INHB`å’Œ`INHC`
- æ­¤å¤–ï¼Œè¿˜éœ€å°†ä½¿èƒ½å¼•è„šè¿æ¥åˆ°`EN-GATE`å¼•è„š
- è¦é…ç½®BLDCé©±åŠ¨å™¨ï¼Œæˆ‘ä»¬éœ€è¦ä¸‰ä¸ªå¼•è„šï¼ˆç´«è‰²ï¼‰
  - `M_PWM`ä¸ºé«˜ç”µå¹³æ—¶å¯ç”¨3PWMæ¨¡å¼ï¼ˆä¸ºä½ç”µå¹³æ—¶ï¼Œæ¿è½½æœŸæœ›6PWMä¿¡å·ï¼‰
  - `M_OC`ä¸ºä½ç”µå¹³æ—¶å¯ç”¨è¿‡æµä¿æŠ¤
  - `OC_ADJ`æ¨¡æ‹Ÿè¾“å…¥ï¼Œç”¨äºè°ƒèŠ‚è¿‡æµé™åˆ¶ - è‹¥ä¸å…³å¿ƒï¼Œå¯æ¥é«˜ç”µå¹³
- è¦è¯»å–æ•…éšœä¿¡å·ï¼Œæˆ‘ä»¬éœ€è¦è¯»å–ä¸¤ä¸ªå¼•è„šï¼ˆçº¢è‰²ï¼‰
  - `nFAULT`ä¸ºé«˜ç”µå¹³æ—¶ï¼Œæ¿è½½å¤„äºæ•…éšœçŠ¶æ€
  - `nOCTW`ä¸ºé«˜ç”µå¹³æ—¶ï¼Œè¾¾åˆ°è¿‡æµé™åˆ¶

## ç¼–ç å™¨
- é€šé“`A`å’Œ`B`è¿æ¥åˆ°å¤–éƒ¨ä¸­æ–­å¼•è„š`2`å’Œ`3`
- è‹¥ç¼–ç å™¨æœ‰`index`ä¿¡å·ï¼Œå¯è¿æ¥åˆ°ä»»ä½•å¯ç”¨çš„æ•°å­—å¼•è„šï¼Œæ­¤å¤„æˆ‘ä»¬å°†å…¶è¿æ¥åˆ°å¼•è„š`4`

## ç”µæœº
- ç”µæœºç›¸`a`ã€`b`å’Œ`c`ç›´æ¥è¿æ¥åˆ°æ¿è½½ç«¯å­`OUTA`ã€`OUTB`å’Œ`OUTC`


## ç¤ºä¾‹è¿æ¥
<p><img src="extras/Images/drv8302_connection.jpg " class="width60"></p>


## Arduinoä»£ç 3PWM

ä½¿ç”¨3PWMè¿è¡ŒDRV8302æ¿çš„ä»£ç ä¸å…¶ä»–ä½åŠŸç‡BLDCé©±åŠ¨å™¨çš„ä»£ç å‡ ä¹å®Œå…¨ç›¸åŒã€‚å”¯ä¸€çš„åŒºåˆ«æ˜¯DRV8302çš„é…ç½®è¿‡ç¨‹ã€‚

å› æ­¤ï¼Œè®©æˆ‘ä»¬é¦–å…ˆå¼€å§‹å®šä¹‰æˆ‘ä»¬åœ¨æ¿ä¸Šä½¿ç”¨çš„å¼•è„šï¼š

```cpp
// DRV8302 pins connections
// don't forget to connect the common ground pin
#define INH_A 9
#define INH_B 10
#define INH_C 11
#define EN_GATE 8
#define M_PWM 6 
#define M_OC 5
#define OC_ADJ 7
```

å˜é‡`INH_A`ã€`INH_B`ã€`INH_C`å’Œ`EN_GATE`ç›´æ¥æä¾›ç»™`BLDCDriver3PWM`ç±»æ„é€ å‡½æ•°ã€‚

```cpp
// driver instance
BLDCDriver3PWM driver = BLDCDriver3PWM(INH_A, INH_B, INH_C, EN_GATE);
```

ä»£ç ä¸­å¦ä¸€ä¸ªç‰¹å®šäºDRV8302çš„éƒ¨åˆ†æ˜¯ï¼Œéœ€è¦åœ¨`setup()`å‡½æ•°çš„å¼€å¤´æ·»åŠ ç›¸å…³é…ç½®ã€‚

```cpp
// DRV8302 specific code
// M_OC  - enable over-current protection
pinMode(M_OC,OUTPUT);
digitalWrite(M_OC,LOW);
// M_PWM  - enable 3pwm mode
pinMode(M_PWM,OUTPUT);
digitalWrite(M_PWM,HIGH);
// OD_ADJ - set the maximum over-current limit possible
// Better option would be to use voltage divisor to set exact value
pinMode(OC_ADJ,OUTPUT);
digitalWrite(OC_ADJ,HIGH);
```
å…¶ä½™éƒ¨åˆ†æ˜¯è¿è¡ŒBLDCç”µæœºçš„å¸¸è§„<span class="simple">ç®€æ˜“<span class="foc">FOC</span>åº“</span>ä»£ç ã€‚


ä»¥ä¸‹æ˜¯è¯¥é¡¹ç›®çš„å®Œæ•´ä»£ç ï¼š
```cpp
#include <SimpleFOC.h>

// DRV8302 pins connections
// don't forget to connect the common ground pin
#define INH_A 9
#define INH_B 10
#define INH_C 11
#define EN_GATE 8
#define M_PWM 6 
#define M_OC 5
#define OC_ADJ 7

// motor instance
BLDCMotor motor = BLDCMotor(11);

// driver instance
BLDCDriver3PWM driver = BLDCDriver3PWM(INH_A, INH_B, INH_C, EN_GATE);

// encoder instance
Encoder encoder = Encoder(2, 3, 8192);
// channel A and B callbacks
void doA(){encoder.handleA();}
void doB(){encoder.handleB();}

// commander interface
Commander command = Commander(Serial);
void onMotor(char* cmd){ command.motor(&motor, cmd); }

void setup() {

  // initialize encoder sensor hardware
  encoder.init();
  encoder.enableInterrupts(doA, doB); 
  // link the motor to the sensor
  motor.linkSensor(&encoder);

  // DRV8302 specific code
  // M_OC  - enable over-current protection
  pinMode(M_OC,OUTPUT);
  digitalWrite(M_OC,LOW);
  // M_PWM  - enable 3pwm mode
  pinMode(M_PWM,OUTPUT);
  digitalWrite(M_PWM,HIGH);
  // OD_ADJ - set the maximum over-current limit possible
  // Better option would be to use voltage divisor to set exact value
  pinMode(OC_ADJ,OUTPUT);
  digitalWrite(OC_ADJ,HIGH);

  // configure driver
  driver.voltage_power_supply = 12;
  driver.init();
  motor.linkDriver(&driver);

  // choose FOC modulation
  motor.foc_modulation = FOCModulationType::SpaceVectorPWM;

  // set control loop type to be used
  motor.controller = MotionControlType::torque;

  // controller configuration based on the control type 
  motor.PID_velocity.P = 0.2;
  motor.PID_velocity.I = 20;

  // velocity low pass filtering time constant
  motor.LPF_velocity.Tf = 0.01;

  // angle loop controller
  motor.P_angle.P = 20;
  
  // angle loop velocity limit
  motor.velocity_limit = 50;
  // default voltage_power_supply
  motor.voltage_limit = 12;

  // use monitoring with serial for motor init
  // monitoring port
  Serial.begin(115200);
  // comment out if not needed
  motor.useMonitoring(Serial);

  // initialize motor
  motor.init();
  // align encoder and start FOC
  motor.initFOC();

  // set the initial target value
  motor.target = 2;

  // define the motor id
  command.add('M', onMotor, "motor");
  
  _delay(1000);
}


void loop() {
  // iterative setting FOC phase voltage
  motor.loopFOC();

  // iterative function setting the outer loop target
  // velocity, position or voltage
  // if target not set in parameter uses motor.target variable
  motor.move();

  // user communication
  command.run();
}
```

## Arduinoä»£ç 6PWM

ä½¿ç”¨6PWMè¿è¡ŒDRV8302æ¿çš„ä»£ç ï¼Œæˆ‘ä»¬éœ€è¦æ ¹æ®æ‰€ä½¿ç”¨çš„å¾®æ§åˆ¶å™¨æ­£ç¡®é…ç½®å¼•è„šã€‚

Arduino unoå¼•è„šåˆ†é…ç¤ºä¾‹å¦‚ä¸‹ã€‚
```cpp
// DRV8302 pins connections
// don't forget to connect the common ground pin
#define INH_A 5
#define INH_B 9
#define INH_C 11
#define INL_A 6
#define INL_B 10
#define INL_C 3
#define EN_GATE 8
#define M_PWM 6 
#define M_OC 5
#define OC_ADJ 7
```

å¯¹äºstm32 Nucleoæ¿ï¼Œä¸Šè¿°å¼•è„šåˆ†é…ä¸é€‚ç”¨ï¼Œä½†æœ‰ç›¸åº”é€‚ç”¨çš„å¼•è„šåˆ†é…ã€‚
```cpp
// DRV8302 pins connections
// don't forget to connect the common ground pin
#define INH_A 7
#define INH_B 6
#define INH_C 5
#define INL_A 2
#define INL_B 3
#define INL_C 4
#define EN_GATE 8
#define M_PWM 9 
#define M_OC 10
#define OC_ADJ 11
```


å˜é‡`INH_A`ã€`INH_B`ã€`INH_C`ã€`INL_A`ã€`INL_B`ã€`INHL_C`å’Œ`EN_GATE`ç›´æ¥æä¾›ç»™`BLDCDriver6PWM`ç±»æ„é€ å‡½æ•°ã€‚

```cpp
// driver instance
BLDCDriver6PWM driver = BLDCDriver6PWM(INH_A, INL_A, INH_B,INL_B, INH_C, INL_C, EN_GATE);
```


ä»£ç ä¸­å¦ä¸€ä¸ªç‰¹å®šäºDRV8302çš„éƒ¨åˆ†æ˜¯ï¼Œéœ€è¦åœ¨`setup()`å‡½æ•°çš„å¼€å¤´æ·»åŠ ç›¸å…³é…ç½®ã€‚

```cpp
// DRV8302 specific code
// M_OC  - enable over-current protection
pinMode(M_OC,OUTPUT);
digitalWrite(M_OC,LOW);
// M_PWM  - enable 6pwm mode (can be left open)
pinMode(M_PWM,OUTPUT);
digitalWrite(M_PWM,LOW);
// OD_ADJ - set the maximum over-current limit possible
// Better option would be to use voltage divisor to set exact value
pinMode(OC_ADJ,OUTPUT);
digitalWrite(OC_ADJ,HIGH);
```
å…¶ä½™éƒ¨åˆ†æ˜¯è¿è¡ŒBLDCç”µæœºçš„å¸¸è§„<span class="simple">ç®€æ˜“<span class="foc">FOC</span>åº“</span>ä»£ç ã€‚


ä»¥ä¸‹æ˜¯è¯¥é¡¹ç›®çš„å®Œæ•´ä»£ç ï¼š
```cpp
#include <SimpleFOC.h>

// DRV8302 pins connections
// don't forget to connect the common ground pin
#define INH_A 5
#define INH_B 9
#define INH_C 11
#define INL_A 6
#define INL_B 10
#define INL_C 3
#define EN_GATE 8
#define M_PWM 6 
#define M_OC 5
#define OC_ADJ 7

// motor instance
BLDCMotor motor = BLDCMotor(11);

// driver instance
BLDCDriver6PWM driver = BLDCDriver6PWM(INH_A, INL_A, INH_B,INL_B, INH_C, INL_C, EN_GATE);

// encoder instance
Encoder encoder = Encoder(2, 3, 8192);
// channel A and B callbacks
void doA(){encoder.handleA();}
void doB(){encoder.handleB();}

// commander interface
Commander command = Commander(Serial);
void onMotor(char* cmd){ command.motor(&motor, cmd); }

void setup() {

  // initialize encoder sensor hardware
  encoder.init();
  encoder.enableInterrupts(doA, doB); 
  // link the motor to the sensor
  motor.linkSensor(&encoder);

  // DRV8302 specific code
  // M_OC  - enable over-current protection
  pinMode(M_OC,OUTPUT);
  digitalWrite(M_OC,LOW);
  // M_PWM  - enable 6pwm mode (can be left open)
  pinMode(M_PWM,OUTPUT);
  digitalWrite(M_PWM,LOW);
  // OD_ADJ - set the maximum over-current limit possible
  // Better option would be to use voltage divisor to set exact value
  pinMode(OC_ADJ,OUTPUT);
  digitalWrite(OC_ADJ,HIGH);

  // configure driver
  driver.voltage_power_supply = 12;
  driver.init();
  motor.linkDriver(&driver);

  // choose FOC modulation
  motor.foc_modulation = FOCModulationType::SpaceVectorPWM;

  // set control loop type to be used
  motor.controller = MotionControlType::torque;

  // controller configuration based on the control type 
  motor.PID_velocity.P = 0.2;
  motor.PID_velocity.I = 20;

  // velocity low pass filtering time constant
  motor.LPF_velocity.Tf = 0.01;

  // angle loop controller
  motor.P_angle.P = 20;
  
  // angle loop velocity limit
  motor.velocity_limit = 50;
  // default voltage_power_supply
  motor.voltage_limit = 12;

  // use monitoring with serial for motor init
  // monitoring port
  Serial.begin(115200);
  // comment out if not needed
  motor.useMonitoring(Serial);

  // initialize motor
  motor.init();
  // align encoder and start FOC
  motor.initFOC();

  // set the initial target value
  motor.target = 2;
  
  // define the motor id
  command.add('M', onMotor, "motor");

  _delay(1000);
}


void loop() {
  // iterative setting FOC phase voltage
  motor.loopFOC();

  // iterative function setting the outer loop target
  // velocity, position or voltage
  // if target not set in parameter uses motor.target variable
  motor.move();

  // user communication
  command.run();
}
```